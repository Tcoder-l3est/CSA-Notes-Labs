# CH2 Instruction Systems

> 指令系统

三种类型指令系统，CISC，RISC，VLIW：超长指令字

指令系统的设计：指令的格式设计、指令系统的功能设计、指令系统的性能评价

## 数据表示

确定哪些数据类型用数据表示来实现的原则
• 缩短程序的运行时间
• 减少CPU与主存储器之间的通信量
• 这种数据表示的通用性和利用率

## 高级数据表示

---

1. 自定义数据表示

数据的属性通过指令中的操作码来解释，高级语言适用类型说明语句指定数据类型，运算符不反应数据类型，高级语言和机器语言之间的语义差距需要依靠编译器弥补

为了缩短高级语言和机器语言的语义差距，可以**让机器中的每个数据都加上类型标识符** 也就是类似于描述符

![image-20220524153654129](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220524153654129.png)

[例题] 假设X处理机的数据不带标志符，其指令字长和数据字长均为**32位**；Y处理机的数据带标志符，数据字长增加至**35位**，其中3位是标志符，其指令字长由32位减少至30位。并**假设一条指令平均访问两个操作数，每个操作数平均被访问R次**。分别计算这两种不同类型的处理机中程序所占用的存储空间。

[解答] X和Y处理机程序占用的存储空间总和分别为

			32I是指令占用的空间、2*32 / R 操作数空间？
	
			$B_x = 32I + 2*32 / R,B_y = 30I + 2*35I / R$
	
			比值：$B_y / B_x = \frac{15R+35}{16R+32}$
	
			当𝑅 > 3时，有By / Bx <1;而实际应用中经常是𝑅 > 10。所以，标志符的处理机所占用的存储空间通常要小。

标识符数据表示方法的[优点]：

1. 简化了指令系统。
2. 由硬件实现一致性检查和数据类型转换。
3. 简化程序设计，缩小了人与计算机之间的语义差距。
4. 简化编译器，使高级语言与机器语言之间的语义差距大大缩短。
5. 支持数据库系统，一个软件不加修改就可适用于多种数据类型。
6. 方便软件调试，在每个数据中都有陷井位。

[缺点]：

1. 数据和指令长度可能不一致：可以通过精心设计指令系统来解决
2. 指令[执行速度]降低，但是采用标志符设计，程序的设计编译调试实践都会降低
3. 硬件复杂度增加

---

2. 数据描述符：对向量、数据、记录等数据，由于元素属性相同，采用数据描述符

   数据描述符与标志符的区别：标志符只作用于一个数据，而**数据描述符要作用于一组数据**。

3. 向量、数组数据表示

   增设数组数据表示，组成向量机

   对于向量A，需要指明**基地址、位移量、向量长度、元素步距**

   向量有效长度的起点：基地址+位移量

4. 堆栈数据表示

   堆栈数据结构在**编译和子程序**调用中很有用

   堆栈机器的特点：1）有高速寄存器组成的硬件堆栈；2）丰富的堆栈操作指令，功能强大；3）支持高级语言编译；4）支持子程序的嵌套和递归调用

5. 原则：看系统效率是否提高：时间和存储空间是否减少

   通用性和利用率是否提高

6. ==浮点数表示==

   | 数符 | 阶符 | 阶码数值 | 小数点 | 尾数 |
   | ---- | ---- | -------- | ------ | ---- |
   | 1bit | 1bit | p位      | .      | m位  |
   |      |      |          |        |      |

   ![image-20220531103218628](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220531103218628.png)

   最小尾数：1 * $r_m^{-1}$ 

   最大尾数：**$$全111最大1 - r_m^{-m'}$$**

## 寻址技术

### 编址方式

- 一般：字节编址，字访问
-  部分机器：位编址，字访问
-  辅助存储器：块编址，位访问

字节编址 *字访问*的问题：

[谈字节编址字访问的地址信息浪费问题_TalesOV的博客-CSDN博客](https://blog.csdn.net/TalesOV/article/details/104572296)

关于地址的浪费：

字编址32位去访问，地址的最低两位都是00.如果32位机器按照半字（两个字节）寻址，那么最后一个二进制位会是0

==与访问的最小单位有关系==

==双字地址最末三个二进制位必须为000，单字地址最末两位必须为00，半字地址最末一位必须为0==

**大端小端问题**

0x123456

大端：数据从高字节向低字节排列(从左往右 0x123456)

小端：数据从低字节向高字节排列(0x654321)

**零地址空间个数(不懂)**

•三个零地址空间：通用寄存器、主存储器、输入输出设备独立编址
• 两个零地址空间：主存储器与输入输出设备统一编址
• 一个零地址空间：最低端是通用寄存器，最高端是输入输出设备，
中间为主存储器
• 隐含编址方式：堆栈、Cache等

*一个零地址空间，即所有存储设备统一编址，地址低端是通用寄存器，最高端是I/O设备，中间绝大多数给主存。*

**并行存储器的编址技术**
• 高位交叉编址：主要用来扩大存储器容量。
• 低位交叉编址：主要是提高存储器速度。

模m低位交叉编址：

![image-20220531110320904](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220531110320904.png)

寻址规则
• 体地址𝑗＝𝐴 𝑚𝑜𝑑 𝑚
• 体内地址𝑖 = 𝐴/𝑚

**适合于单处理机内的数据存取和带Cache的主存**

同样还有模M高位交叉编址

**适合于共享存储器的多机系统，适用于指令和数据分别存于不同分体中**

![image-20220531110756228](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220531110756228.png)

**输入输出设备的编址**

一台设备一个地址：仅对输入输出设备本身进行编址，需要通过指
令中的操作码来识别该输入输出设备接口上的有关寄存器
Ø 一台设备两个地址：数据寄存器、状态或控制寄存器。
Ø 多个编址寄存器共用同一个地址的方法：
• 依靠地址内部来区分，适用于被编址的寄存器的长度比较短
• “下跟法”隐含编址方式，必须按顺序读写寄存器。
Ø 一台设备多个地址：增加编程的困难

### 寻址方式

- 立即数寻址
- 面向寄存器寻址
- 面向主存储器寻址
  - 直接寻址
  - 间接寻址
  - 变址寻址
- 面向堆栈寻址

**定位方式主要研究程序的主存物理地址在什么时间确定，采用什**
**么方式来实现**

地址转化

程序需要定位的主要原因：
• 程序的独立性
• 程序的模块化设计
• 数据结构在程序运行过程中，其大小往往是变化的
• 有些程序本身很大，大于分配给它的主存物理空间

**定位方式**

Ø 直接定位方式：在程序装入主存储器之前，程序中的指令和数据的主存物理就已经确定了的称为直接定位方式。
Ø 静态定位：在程序装入主存储器的过程中随即进行地址变换，确定指令和数据的主存物理地址的称为静态定位方式。
Ø 动态定位：在程序执行过程中，当访问到相应的指令或数据时才进行地址变换，确定指令和数据的主存物理地址的称为动态定位方式。

动态定位需要：增加相应的基址寄存器和地址加法器硬件，在程序不做变换直接装入主存的同时，将装入主存的起始地址存入对应该道程序使用的基址寄存器中

程序执行时，通过地址加法器将逻辑地址加上基址寄存器内的程序基址，形成有效的物理地址

可在指令中加入相应的标志位来指明指令地址是否需要加基址

## 指令系统的优化设计

主要目标：**节省程序的存储空间，指令格式尽量规整，便于译码**

### 操作码的优化表示

操作码的三种编码方法：固定长度、Huffman编码、扩展编码

优化操作码编码的目的：节省程序存储空间

#### Huffman编码

概率高的用最短的位数来处理

操作码的平均长度公式：$$H = -\sum pi*log_2p^i,pi是第i种操作码出现的概率$$

 固定长编码相对于最优Huffman编码的信息冗余量：$R = 1-\frac{-\sum pi*log_2p_i}{log_2n} 分母需要向上取整$

**最短平均长度$H_{opt} 是一个理想值$** 

然后算信息冗余量R = 1 - Hopt / H实际 就是冗余量

huffman缺点：

- 操作码长度很不规整，硬件译码困难
- 与地址码共同组成固定长的指令比较困难

#### 扩展编码法

操作码长度不是定长，但是只有 **有限几种码长**

![image-20220531161510314](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220531161510314.png)

**4-8-12等长扩展编码法：**

![image-20220531163310540](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220531163310540.png)

一个是从每次15个  一个是 8/64/512

### RISC CISC

- 按CISC方向：增强原有指令的功能以及设置更为复杂的新指令，取代
  原先由软件子程序完成的功能，实现软件功能的硬化
- 按RISC方向：通过减少指令种类和简化指令功能来降低硬件设计的复
  杂度，提高指令执行速度

RISC 定义以及特点

1) 减少指令和寻址方式种类：指令系统只选择高频指令，减少指令数量，一般不超
过100条；减少寻址方式，一般不超过两种
2) 固定指令格式：精减指令格式限制在两种以内，并使全部指令都在相同的长度
3) 大多数指令在单周期内完成：让所有指令都在一个周期内完成
4) 采用LOAD/STORE结构：扩大通用寄存器数量（一般不少于32个），尽量减少访存，
所有指令只有存（STORE）/取（LOAD）指令可以访存，其他指令只对寄存器操作
5) 硬布线逻辑：大多数指令采用硬联逻辑，少数指令采用微程序实现，提高指令执
行速度
6) 优化编译：通过精减指令和优化设计编译程序，简单有效地支持高级语言实现

#### 延时转移

**为了使指令流水线不断流，在转移指令之后插入一条没有数据相关和控制相关的有效指令，而转移指令被延迟执行，这种技术称为延迟转移技术**

采用指令延迟转移技术时，指令序列的调整由编译器自动进行，用户不必干预

> 类似于指令重排

采用延迟转移技术的两个限制条件
• 被移动指令在移动过程中与所经过的指令之间没有数据相关
• 被移动指令不破坏条件码，至少不影响后面的指令使用条件码

Ø如果找不到符合上述条件的指令，必须在条件转移指令后面插入空操作
Ø如果指令的执行过程分为多个流水段，则要插入多条指令
• 插入1条指令成功的概率比较大，插入2条或2条以上指令成功的概率明显下降(找不到啊)

#### 指令取消技术

采用指令延时技术，经常找不到可以用来调整的指令，
• 可考虑采用另一种方法：指令取消技术
• 分为两种情况：
(1) 向后转移（适用于循环程序）
(2) 向前转移(IF THEN )

#### 重叠寄存器窗口技术

原因：在RISC中，子程序比CISC中多，因为传送参数而访问存储器的信息
量很大
Ø实现方法：设置一个数量比较大的寄存器堆，并把它划分成很多个窗口。
在每个过程使用的几个窗口中：
• 有一个窗口是与前一个过程共用
• 有个窗口是与下一个过程共用

![image-20220531173532583](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220531173532583.png)

#### 指令流调整技术

#### 高速缓冲存储器Cache

#### 优化设计编译器

### 指令系统的发展和改进