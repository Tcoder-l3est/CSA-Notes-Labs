# 实验三 用WinDLX模拟器完成求素数程序

> 实验信息
>
> 姓名： 	张朝阳			班级： 19.1
>
> 学号：	201900180091      时间：2022.5.3
>

## 实验目的

通过实验，熟练掌握 WINDLX 的操作方法，特别注意在单步执行 WinDLX 程序中，流水线中指令的节拍数

## 实验环境

操作系统：Windows XP

软件环境：WinDLX

## 实验内容

- 用 WinDLX 模拟器执行求素数程序 prim.s。这个程序计算若干个整数的素数。

- 单步执行两轮程序，求出素数 2 和 3。
- 在执行程序过程中，注意体验单步执行除法和乘法指令的节拍数，并和主菜单 configuration/floating point slages 中的各指令执行拍数进行比较。


## 实验步骤



### 分析

## 源码阅读

prim.s 代码以及注释如下：

```assembly

;------------------------------------------------ ------------------
; 程序从符号 main 开始
; 生成一个表,其中包含素数
; r1 是标志table下一个要写入的素数的位置索引
; r2 是用来遍历2---INF的
; r3 是用来遍历table 0---r1 从而判断r2 是不是素数 
; 一个数字r2
;	如果遍历完所有的table元素仍不能被整除
; 		则认为是一个素数，并写入到table[r1] 里面
;	如果发现能被整除,则一定不是素数
;		则r2++ 遍历判断下一个自然数
;------------------------------------------------ ------------------
		.data

		;*** table的size = count = 10
		;*** table 大小为 10 * 4 = 40
		.global		Count
Count:		.word		10
		.global		Table
Table:		.space		Count*4


		.text
		.global	main
main:
		;*** 初始化
		addi		r1,r0,0		; r1记录数组已经写入数的索引 初始 r1 = 0 
		addi		r2,r0,2 	; r2是当前判断是否是素数的数 初始 r2 = 2

		;*** 判断R2能够被Table中的数值整除
NextValue:	addi	r3,r0,0 	; 辅助索引 r3=0,用于遍历Table
Loop:		seq		r4,r1,r3	; 判断是否遍历完Table 即判断r1 == r3?
		bnez		r4,IsPrim	; 如果遍历完,说明R2是素数,反之不是
		lw          r5,Table(R3); 取出Table[R3] -> r5
		divu		r6,r2,r5	; r2 / r5 -> r6 
		multu		r7,r6,r5	; r6 * r5 -> r7	
		subu		r8,r2,r7	; r2 - r7 -> r8	 r8为r5/r2的余数
		beqz		r8,IsNoPrim	; 判断r8,0说明R5整除R2,确定r2不为素数
		addi		r3,r3,4		; r3 += 4 goto next table entry
		j           Loop		; goto Loop

IsPrim: 	;*** 找到素数,将其写入table,更新索引
		sw          Table(r1),r2; 将素数R2写入table[r1]
		addi		r1,r1,4		; r1++ 下一个索引位置

		;*** 'Count' reached?
		lw		r9,Count		; 10(count) -> r9
		srli	r10,r1,2		; r1 逻辑右移2位 -> r10 (除4)
		sge		r11,r10,r9		; 判断 r10 > r9
		bnez	r11,Finish		; r11 = 1 说明table已经写满  需要结束

IsNoPrim:	;*** Check next value
		addi	r2,r2,1 		; r2++
		j		NextValue		; jump to NextValue
		
Finish: 	;*** end
		trap	0
```



## 涉及指令

prim所使用的部分DLX指令如下

| 指令              | 含义                                                |
| ----------------- | --------------------------------------------------- |
| seq  r4,r1,r2     | 如果r1 = r2，r4为1，否则为0                         |
| bnez r4,IsPrim    | 如果r4不为0，则跳转到IsPrim,反之顺序执行            |
| sgt  r3,r1,r2     | 如果r1 > r2，r3为1，否则为0                         |
| j & jal           | j 是跳转，jal是跳转并链接，结束后继续执行原来的指令 |
| divu  r6,r2,r5    | 无符号数r2/r5->r6                                   |
| multu r7,r6,r5    |                                                     |
| subu  r8,r2,r7    |                                                     |
| beqz  r8,IsNoPrim |                                                     |

## 实验心得

1. 在input 6 and 3时，Forwarding 技术导致的加速比= $\frac{136}{121} = 1.124$ 快大约12.4%

2. 在input 6 and 1时，Forwarding 技术导致的加速比= $\frac{180}{157} = 1.146$ 快大约14.6%

3. 明白了gcm的设计思想，这里主要用了更相减损法，还有辗转相除法以及Stein算法等。

4. 针对流水线而言，本次实验中主要存在数据相关，具体是RAW(Read and Write) 读写/写读相关，没有WAW，而stalls 除了RAW 还有因为Control 以及 Trap Stalls

   ![image-20220426204810740](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220426204810740.png)

5. Control 控制相关指的是：当流水线遇到分支指令和其它能够改变 PC 值的指令时，就会发生控制相关。(例如跳转指令等)

6. 本实验主要通过定向技术减少数据相关带来的暂停，将一个结果直接传送到所有需要它的功能单元。

7. 通过调试汇编代码，查看流水线结构以及寄存器，进一步体会了流水线执行过程以及流水线中存在的优化机制。
