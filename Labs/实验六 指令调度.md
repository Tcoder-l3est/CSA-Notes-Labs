# 实验六 指令调度

> 实验信息
>
> 姓名： 	张朝阳			班级： 19.1
>
> 学号：	201900180091      时间：2022.5.24
>

## 实验目的

通过本实验，加深对指令调度的理解，了解指令调度技术对 CPU 性能改进的好处。

## 实验环境

操作系统：Windows XP Professional

软件环境：WinDLX

CPU: Intel(R) Core(TM) i5-8300H CPU @ 2.30GHz   2.30 GHz

## 实验内容

- 通过 Configuration 菜单中的“Floating point stages”选项，把除法单元数设置为 3，把加法﹑乘法﹑除法的延迟设置为 3 个时钟周期。
- 用 WinDLX 模拟器运行调度前的程序 sch-before.s 。记录程序执行过程中各种相关发生的次数以及程序执行的总时钟周期数。 
- 用 WinDLX 模拟器运行调度后的程序 sch-after.s ，记录程序执行过程中各种相关发生的次数以及程序执行的总时钟周期数。 
- 根据记录结果，比较调度前和调度后的性能。 
- 论述指令调度对于提高 CPU 性能的意义。

## 实验步骤

### 调度前

把除法单元数设置为 3，把加法﹑乘法﹑除法的延迟设置为 3 个时钟周期，load  sch-before.s  文件，运行调度前的程序。

#### 发生相关之处

![image-20220524104454198](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220524104454198.png)

1. cvti2f f7,f1 和 上面lf指令 在寄存器f1 发生**数据相关**，lf 指令需要在WB阶段才能写入，而cvti2f则需要在ID阶段读入，当然这里面使用了定向技术，使得整个stall阶段减少了，可以在MEM阶段通过定向转移到INTEX阶段进行执行
2. nop 和上面 cvti2f 发生了**结构相关**，译码器冲突
3. addf f3,f1,f2 和上面divf 指令发生**数据相关**，等到寄存器f2的计算结果
4. divf f10,f3,f7 发生了**结构相关**，运算器冲突，以及**数据相关**，关于寄存器f3
5. div f4,f11,f7 发生了**结构相关**，译码器冲突
6. multf f6,f4,f5 发生了**数据相关**，原因在于和之前divf指令，divf指令需要计算出寄存器f5的结果
7. divf,f13,f6,f7 发生了**结构相关和数据相关**

==总共发生了**5**次数据相关以及**4**次结构相关==

#### 时钟周期

![image-20220524105422064](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220524105422064.png)

程序执行的总周期数为27 cycles，总共10条有效指令，**吞吐率 =  10 / 27 = 37.04%**

|     相关类型      | 相关次数 |           stall周期           |  比例  |
| :---------------: | :------: | :---------------------------: | :----: |
|    RAW stalls     |    5     |               9               | 33.33% |
| Structural stalls |    4     | 0(因为都和数据相关在同一周期) | 0.00%  |
|    Trap stalls    |    1     |               7               | 25.92% |
|       Total       |    10    |              16               | 59.26% |

### 调度后

把除法单元数设置为 3，把加法﹑乘法﹑除法的延迟设置为 3 个时钟周期，load  sch-after.s  文件，运行调度后的程序。

#### 发生相关之处

![image-20220524111019372](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220524111019372.png)

1. cvti2f f7,f1 发生数据相关
2. nop 发生结构相关
3. multf f6,f4,f5 发生数据相关
4. divf f10,f3,f7 发生结构相关
5. divf f13,f6,f7 发生了数据相关

发生了三次结构相关、两次数据相关

#### 时钟周期

![image-20220524111236794](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220524111236794.png)

总共21cycles，**吞吐率 = 10 / 21 = 47.62% ** 

|     相关类型      | 相关次数 |           stall周期           |  比例  |
| :---------------: | :------: | :---------------------------: | :----: |
|    RAW stalls     |    3     |               3               | 14.28% |
| Structural stalls |    2     | 0(因为都和数据相关在同一周期) | 0.00%  |
|    Trap stalls    |    1     |               6               | 28.57% |
|       Total       |    6     |               9               | 46.86% |

## 性能分析

调度前后指令不变，仅仅改变了指令执行的顺序，而吞吐率从调度前的37.04% 提升到了 47.62%

### 指令调度

**指令调度使指令顺序重新组合，可以消除部分的数据冲突**，从而通过指令调度技术显著地提高了CPU的使用率，大大减少了指令冲突的次数，提高了CPU的性能。 指令调度的优劣直接影响CPU性能的发挥好坏，好的指令调度可以让停顿周期大幅度减少。

## 源码阅读

 sch-before.s代码以及注释如下：

```assembly
;-------------------------------------------------------------------
; sch-before.s
; 模拟指令调度的示例，调度前的指令
;-------------------------------------------------------------------
		.data					; data
		.global		ONE			; 
ONE:	.word		1			;
		.text					;
		.global	main			;
main:
		lf          f1,ONE		; 载入单精度浮点数 one -> f1
		cvti2f		f7,f1		; int 转 float
		nop                     ; 
		divf		f1,f8,f7	; f8 / f7 -> f1
		divf		f2,f9,f7	; f9 / f7 -> f2
		addf		f3,f1,f2	; f1+f2->f3
		divf		f10,f3,f7	; f3 / f7 -> f10
		divf		f4,f11,f7	; f11 / f4 -> f4
		divf		f5,f12,f7	; f12 / f7 -> f5
		multf		f6,f4,f5	; f4 * f5 -> f6
		divf		f13,f6,f7	; f6 / f7 -> f13
Finish: 	
		trap		0
```

 sch-after.s代码以及注释如下：

```assembly
;-------------------------------------------------------------------
; 模拟指令调度的示例，重新排序的指令
; sch-afer.s
;-------------------------------------------------------------------
		.data
		.global		ONE
ONE:	.word		1
		.text
		.global	main
main:
		lf          f1,ONE		 ; 通过以浮点格式存储在f7 1中将 divf 变为 move
		cvti2f		f7,f1		; 
		nop                      ; 
		divf		f1,f8,f7	;
		divf		f2,f9,f7	;
		divf		f4,f11,f7	; 相比之前，提前该指令，避免了f2寄存器数据相关
		divf		f5,f12,f7	
		addf		f3,f1,f2	
		multf		f6,f4,f5
		divf		f10,f3,f7	; 相比之前，后置该指令，避免了f3寄存器数据相关
		divf		f13,f6,f7	; 相比之前，后置该指令，避免了f6寄存器数据相关
Finish: 	
		trap		0

```



## 涉及指令

所使用的部分DLX指令如下

|     指令     |     含义     |
| :----------: | :----------: |
| cvti2f f7 f1 | int 转 float |

## 实验心得

1. 指令调度时候，对于一些相互影响不大的代码在逻辑结构不变的情况下可以进行顺序的变动；这样数据冲突、结构冲突会有所减少，并且也提高的cpu的效率；
2.  指令调度重排代码中的各个操作。试图最小化等待操作数所浪费的周期数。当然，必须确保新指令序列产生的结果与原来的指令序列是相同的。在很多情况下，调度可以大幅度改进“朴素”代码的性能。
