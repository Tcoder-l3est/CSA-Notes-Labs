# 实验五 数据相关

> 实验信息
>
> 姓名： 	张朝阳			班级： 19.1
>
> 学号：	201900180091      时间：2022.5.17
>

## 实验目的

通过本实验，加深对数据相关的理解，掌握如何使用定向技术来减少数据相关带来的暂停。

## 实验环境

操作系统：Windows XP

软件环境：WinDLX

CPU: Intel(R) Core(TM) i5-8300H CPU @ 2.30GHz   2.30 GHz

## 实验内容

- 在不采用定向技术的情况下（通过 Configuration 菜单中的 Enable Forwarding 选项设置），用 WinDLX 模拟器运行程序 data_d.s 。 
- 记录数据相关引起的暂停时钟周期数以及程序执行的总时钟周期数，计算暂停时钟周期数占总执行周期数的百分比。
- 在采用定向技术的情况下，用 WinDLX 模拟器再次运行程序 data_d.s。
- 记录数据相关引起的暂停时钟周期数以及程序执行的总时钟周期数，计算暂停时钟周期数占总执行周期数的百分比。
- 根据上面记录的数据，计算采用定向技术后性能提高的倍数。

## 实验步骤

load data_d.s 文件，分别不使用定向技术 和 使用定向技术进行运行。

### 不采用定向技术

#### 时钟周期数

![image-20220517152037525](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220517152037525.png)

总共用了202Cycles，因为数据相关暂停的周期数RAW stalls = 104 Cycles

占总周期数的百分比为**51.48%**

#### 发生数据相关之处

1. **addui r2,r2,0x134** 需要用的r2的值，而R2则是上面lhi 计算出来的，在lhi指令的wb阶段才写入寄存器R2，但是addui在ID阶段就要从寄存器r2读出结果，所以产生了**写-读数据相关**。

![image-20220524093715801](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220524093715801.png)

2. **addui r3,r3,0x15c** 和上面类似，因为需要用的lhi r3,0x0的计算结果，lhi在wb阶段才写入寄存器r3，但是addui在ID阶段就要从寄存器R3读出计算结果，产生**写-读数据相关**。

![image-20220524093750161](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220524093750161.png)

3. add r1,r1,r3  使用了R1寄存器，而R1寄存器结果是由上面lw r1,0x0(r2) 计算得出的，需要在WB阶段写入寄存器R1，而add指令则在ID阶段就要从寄存器R3读出结果，产生了**写-读数据相关**

![image-20220524093823406](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220524093823406.png)

4. sw 0x0(r2),r1需要用到addui r1,r1,r3的计算结果，而addui在WB阶段才把计算结果写入寄存器R1，但是SW指令在ID阶段就要从寄存器R1读出计算结果，产生了**写读数据相关**

![image-20220524094945926](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220524094945926.png)

5. addi r5,r5,0xa需要用到lhi r5,0x0(r1)的计算结果，而lhi 在WB阶段才把计算结果写入寄存器R5，但是addi 在ID阶段就要从寄存器R5读出计算结果，产生了**写读数据相关**

![image-20220524094205004](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220524094205004.png)

6. sub r4,r3,r2需要用到addi r2,r2,0x4的计算结果，而addi 在WB阶段才把计算结果写入寄存器R2，但是sub  在ID阶段就要从寄存器R2读出计算结果，产生了**写读数据相关**

![image-20220524094239032](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220524094239032.png)

7. bnez r4,loop需要用到sub r4,r3,r2的计算结果，而sub在WB阶段才把计算结果写入寄存器R4，但是bnez在ID阶段就要从寄存器R4读出计算结果，产生了**写读数据相关**

![image-20220524094310205](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220524094310205.png)

### 采用定向技术

#### 时钟周期数

采用Forwarding技术，总共使用了128 个时钟周期，因为数据相关而产生的暂停即RAW-Stalls = 30 cycles，占总周期数的百分比为: **23.44%**

![image-20220517152457345](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220517152457345.png)

#### 发生数据相关之处

1. add r1,r1,r3 和上面lw r1 0x0(r2) 发生了数据相关，主要是因为r1寄存器，并且因为相邻的原因，无法实现forwarding避免stall，而对于R3寄存器的数据相关则是forwarding技术解决了这个问题。

![image-20220517154046732](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220517154046732.png)

2. addi r5,r5,0xa 和上面 lw r5,0x0(r1) 发生了数据相关，因为R5寄存器的数据相关。

![image-20220517154205061](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220517154205061.png)

3. bnez r4,loop 因为R4寄存器和sub r4mr3,r2 发生数据相关

![image-20220517154247286](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220517154247286.png)

### 性能分析

根据上面的记录，采用定向技术使用了128个周期，不采用使用了202个周期，提高了

$$(202 / 128) - 100\% = 57.81\%$$ ，**性能提高倍数为 57.81%**

## 源码阅读

 data_d.s 代码以及注释如下：

```assembly
;--------------------------------------------------------------
; 测试数据相关
; R3寄存器一直是B的地址
; R2从A开始每次 +0x4 
; Loop Ten Times
;--------------------------------------------------------------
      LHI     R2, (A>>16) & 0xFFFF     ; R2 <- A
      ADDUI   R2, R2, A & 0xFFFF       ; 分别高位低位,发生数据相关
      LHI     R3, (B>>16)&0xFFFF       ; R3 <- B
      ADDUI   R3, R3, B&0xFFFF         ; 分别高位低位,发生数据相关
loop:  
      LW     R1, 0(R2)                 ; A[0] -> R1
      ADD    R1, R1, R3                ; A[0] + B[0] -> R1  与上面数据相关                
      SW     0(R2), R1                 ; R1(A[0] + B[0]) -> A[0],发生数据相关
      LW     R5, 0(R1)                 ; A[0] + B[0] -> R5,发生数据相关
      ADDI   R5, R5, #10               ; R5 = R5 + 0x10(16),发生数据相关
      ADDI   R2, R2, #4                ; R2 = R2 + 0x4
      SUB    R4, R3, R2                ; R4 = R3 - R2,发生数据相关
      BNEZ   R4, loop                  ; 结束条件:R2=R3=B,发生数据相关
      TRAP   #0                        ; Exit
A: .word 0, 4, 8, 12, 16, 20, 24, 28, 32, 36  
B: .word 9, 8, 7, 6, 5, 4, 3, 2, 1, 0  
```



## 涉及指令

 data_d.s 所使用的部分DLX指令如下

|                     指令                     |                含义                 |
| :------------------------------------------: | :---------------------------------: |
|                BNEZ  R4, loop                | R4如果not equal zero，则跳转到loop  |
| A: .word 0, 4, 8, 12, 16, 20, 24, 28, 32, 36 | word类型 A数组，A为地址，字宽为word |

## 实验心得

1. 通过本次实验,我了解到定向技术的主要思想是:在某条指令产生一个计算结果之前，其它指令并不真正需要该计算结果,如果能够将该计算结果从其产生的地方直接送到其它指令需要它的地方，那么就可以避免暂停。
   从而，定向技术的要点可以归纳为;

   - 寄存器文件EX/MEM中的ALU的运算结果总是回送到ALU的输入寄存器。
   - 当定向硬件检测到前一个ALU运算结果的写入寄存器就是当前ALU操作的源寄存器时，那么控制逻辑将前一个ALU运算结果定向到ALU的输入端，后一个ALU操作就不必从源寄存器中读取操作数。

   ![image-20220524100122511](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220524100122511.png)

2. 流水线中的指令所需要的定向结果可能并不仅仅是前一条指令的计算结果， 而且还有可能是前面与其不相邻指令的计算结果

3. 定向技术可以推广到更一般的情况，可以将一个结果直接传送到所有需要它的功能单 元。也就是说，一个结果不仅可以从某一功能单元的输出定向到其自身的输入，而且还可以从某 一功能单元的输出定向到其它功能单元的输入

4. 本次实验的一些数据相关的实例均是有关寄存器操作数的，但是数据相关也有可能发生在一对指 令对存储器同一单元进行读写的时候。

   
